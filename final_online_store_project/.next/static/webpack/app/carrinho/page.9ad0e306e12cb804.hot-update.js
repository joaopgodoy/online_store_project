"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/carrinho/page",{

/***/ "(app-pages-browser)/./components/cart-provider.tsx":
/*!**************************************!*\
  !*** ./components/cart-provider.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CartProvider: () => (/* binding */ CartProvider),\n/* harmony export */   useCart: () => (/* binding */ useCart)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_use_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/hooks/use-auth */ \"(app-pages-browser)/./hooks/use-auth.ts\");\n/* __next_internal_client_entry_do_not_use__ CartProvider,useCart auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst CartContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction CartProvider(param) {\n    let { children } = param;\n    _s();\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { user, getToken, isAuthenticated } = (0,_hooks_use_auth__WEBPACK_IMPORTED_MODULE_2__.useAuth)();\n    // Carregar carrinho do servidor quando o usuário estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CartProvider.useEffect\": ()=>{\n            if (isAuthenticated && user) {\n                fetchCart();\n            } else {\n                // Se não estiver autenticado, carregar do localStorage\n                const savedCart = localStorage.getItem(\"cart\");\n                if (savedCart) {\n                    try {\n                        setItems(JSON.parse(savedCart));\n                    } catch (error) {\n                        console.error(\"Erro ao carregar carrinho:\", error);\n                    }\n                }\n            }\n        }\n    }[\"CartProvider.useEffect\"], [\n        isAuthenticated,\n        user\n    ]);\n    // Salvar no localStorage quando não autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CartProvider.useEffect\": ()=>{\n            if (!isAuthenticated) {\n                localStorage.setItem(\"cart\", JSON.stringify(items));\n            }\n        }\n    }[\"CartProvider.useEffect\"], [\n        items,\n        isAuthenticated\n    ]);\n    const fetchCart = async ()=>{\n        if (!isAuthenticated) return;\n        try {\n            setLoading(true);\n            const token = getToken();\n            const response = await fetch('/api/cart', {\n                headers: {\n                    'Authorization': \"Bearer \".concat(token)\n                }\n            });\n            if (response.ok) {\n                const cartData = await response.json();\n                const transformedItems = cartData.map((item)=>({\n                        id: item.product._id,\n                        name: item.product.name,\n                        descricao: item.product.description,\n                        preco: item.product.price,\n                        categoria: item.product.category,\n                        imagem: item.product.image,\n                        disponivel: item.product.inStock,\n                        quantidade: item.quantity\n                    }));\n                setItems(transformedItems);\n            }\n        } catch (error) {\n            console.error('Erro ao carregar carrinho:', error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const addItem = async function(produto) {\n        let quantity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (isAuthenticated) {\n            try {\n                const token = getToken();\n                const response = await fetch('/api/cart', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': \"Bearer \".concat(token)\n                    },\n                    body: JSON.stringify({\n                        productId: produto.id,\n                        quantity\n                    })\n                });\n                if (response.ok) {\n                    await fetchCart() // Recarregar carrinho\n                    ;\n                } else {\n                    const errorData = await response.json();\n                    throw new Error(errorData.message);\n                }\n            } catch (error) {\n                console.error('Erro ao adicionar ao carrinho:', error);\n                throw error;\n            }\n        } else {\n            // Lógica local para usuários não autenticados\n            setItems((prevItems)=>{\n                const existingItem = prevItems.find((item)=>item.id === produto.id);\n                if (existingItem) {\n                    return prevItems.map((item)=>item.id === produto.id ? {\n                            ...item,\n                            quantidade: item.quantidade + quantity\n                        } : item);\n                } else {\n                    return [\n                        ...prevItems,\n                        {\n                            ...produto,\n                            quantidade: quantity\n                        }\n                    ];\n                }\n            });\n        }\n    };\n    const removeItem = async (produtoId)=>{\n        if (isAuthenticated) {\n            try {\n                const token = getToken();\n                const response = await fetch(\"/api/cart?productId=\".concat(produtoId), {\n                    method: 'DELETE',\n                    headers: {\n                        'Authorization': \"Bearer \".concat(token)\n                    }\n                });\n                if (response.ok) {\n                    await fetchCart();\n                }\n            } catch (error) {\n                console.error('Erro ao remover do carrinho:', error);\n            }\n        } else {\n            setItems((prevItems)=>prevItems.filter((item)=>item.id !== produtoId));\n        }\n    };\n    const updateQuantity = async (produtoId, quantidade)=>{\n        if (quantidade <= 0) {\n            await removeItem(produtoId);\n            return;\n        }\n        if (isAuthenticated) {\n            try {\n                const token = getToken();\n                const response = await fetch('/api/cart', {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': \"Bearer \".concat(token)\n                    },\n                    body: JSON.stringify({\n                        productId: produtoId,\n                        quantity: quantidade\n                    })\n                });\n                if (response.ok) {\n                    await fetchCart();\n                }\n            } catch (error) {\n                console.error('Erro ao atualizar carrinho:', error);\n            }\n        } else {\n            setItems((prevItems)=>prevItems.map((item)=>item.id === produtoId ? {\n                        ...item,\n                        quantidade\n                    } : item));\n        }\n    };\n    const clearCart = async ()=>{\n        if (isAuthenticated) {\n            // Para usuários autenticados, o carrinho será limpo no servidor durante o checkout\n            setItems([]);\n        } else {\n            setItems([]);\n        }\n    };\n    const total = items.reduce((sum, item)=>sum + item.preco * item.quantidade, 0);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CartContext.Provider, {\n        value: {\n            items,\n            addItem,\n            removeItem,\n            updateQuantity,\n            clearCart,\n            total,\n            loading\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/peloro/Desktop/Condominio/online_store_project/final_online_store_project/components/cart-provider.tsx\",\n        lineNumber: 199,\n        columnNumber: 5\n    }, this);\n}\n_s(CartProvider, \"fDSY91YVaG6pvgz5hKNWm3sMLaw=\", false, function() {\n    return [\n        _hooks_use_auth__WEBPACK_IMPORTED_MODULE_2__.useAuth\n    ];\n});\n_c = CartProvider;\nfunction useCart() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CartContext);\n    if (context === undefined) {\n        throw new Error(\"useCart deve ser usado dentro de um CartProvider\");\n    }\n    return context;\n}\n_s1(useCart, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"CartProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY2FydC1wcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFc0Y7QUFFNUM7QUFnQjFDLE1BQU1LLDRCQUFjTCxvREFBYUEsQ0FBOEJNO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdSLCtDQUFRQSxDQUFhLEVBQUU7SUFDakQsTUFBTSxDQUFDUyxTQUFTQyxXQUFXLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sRUFBRVcsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLGVBQWUsRUFBRSxHQUFHWCx3REFBT0E7SUFFbkQscUVBQXFFO0lBQ3JFRCxnREFBU0E7a0NBQUM7WUFDUixJQUFJWSxtQkFBbUJGLE1BQU07Z0JBQzNCRztZQUNGLE9BQU87Z0JBQ0wsdURBQXVEO2dCQUN2RCxNQUFNQyxZQUFZQyxhQUFhQyxPQUFPLENBQUM7Z0JBQ3ZDLElBQUlGLFdBQVc7b0JBQ2IsSUFBSTt3QkFDRlAsU0FBU1UsS0FBS0MsS0FBSyxDQUFDSjtvQkFDdEIsRUFBRSxPQUFPSyxPQUFPO3dCQUNkQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtvQkFDOUM7Z0JBQ0Y7WUFDRjtRQUNGO2lDQUFHO1FBQUNQO1FBQWlCRjtLQUFLO0lBRTFCLGdEQUFnRDtJQUNoRFYsZ0RBQVNBO2tDQUFDO1lBQ1IsSUFBSSxDQUFDWSxpQkFBaUI7Z0JBQ3BCRyxhQUFhTSxPQUFPLENBQUMsUUFBUUosS0FBS0ssU0FBUyxDQUFDaEI7WUFDOUM7UUFDRjtpQ0FBRztRQUFDQTtRQUFPTTtLQUFnQjtJQUUzQixNQUFNQyxZQUFZO1FBQ2hCLElBQUksQ0FBQ0QsaUJBQWlCO1FBRXRCLElBQUk7WUFDRkgsV0FBVztZQUNYLE1BQU1jLFFBQVFaO1lBQ2QsTUFBTWEsV0FBVyxNQUFNQyxNQUFNLGFBQWE7Z0JBQ3hDQyxTQUFT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VUEsQ0FBQ0k7SUFDM0IsSUFBSXFFLFlBQVlwRSxXQUFXO1FBQ3pCLE1BQU0sSUFBSW9ELE1BQU07SUFDbEI7SUFDQSxPQUFPZ0I7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIi9ob21lL3BlbG9yby9EZXNrdG9wL0NvbmRvbWluaW8vb25saW5lX3N0b3JlX3Byb2plY3QvZmluYWxfb25saW5lX3N0b3JlX3Byb2plY3QvY29tcG9uZW50cy9jYXJ0LXByb3ZpZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB0eXBlIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgdHlwZSB7IFByb2R1dG8gfSBmcm9tIFwiQC9saWIvdHlwZXNcIlxuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCJAL2hvb2tzL3VzZS1hdXRoXCJcblxuaW50ZXJmYWNlIENhcnRJdGVtIGV4dGVuZHMgUHJvZHV0byB7XG4gIHF1YW50aWRhZGU6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgQ2FydENvbnRleHRUeXBlIHtcbiAgaXRlbXM6IENhcnRJdGVtW11cbiAgYWRkSXRlbTogKHByb2R1dG86IFByb2R1dG8sIHF1YW50aXR5PzogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gIHJlbW92ZUl0ZW06IChwcm9kdXRvSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuICB1cGRhdGVRdWFudGl0eTogKHByb2R1dG9JZDogc3RyaW5nLCBxdWFudGlkYWRlOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cbiAgY2xlYXJDYXJ0OiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIHRvdGFsOiBudW1iZXJcbiAgbG9hZGluZzogYm9vbGVhblxufVxuXG5jb25zdCBDYXJ0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2FydENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJ0UHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPENhcnRJdGVtW10+KFtdKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgeyB1c2VyLCBnZXRUb2tlbiwgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKClcblxuICAvLyBDYXJyZWdhciBjYXJyaW5obyBkbyBzZXJ2aWRvciBxdWFuZG8gbyB1c3XDoXJpbyBlc3RpdmVyIGF1dGVudGljYWRvXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCAmJiB1c2VyKSB7XG4gICAgICBmZXRjaENhcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZSBuw6NvIGVzdGl2ZXIgYXV0ZW50aWNhZG8sIGNhcnJlZ2FyIGRvIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3Qgc2F2ZWRDYXJ0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjYXJ0XCIpXG4gICAgICBpZiAoc2F2ZWRDYXJ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0SXRlbXMoSlNPTi5wYXJzZShzYXZlZENhcnQpKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGNhcnJlZ2FyIGNhcnJpbmhvOlwiLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgdXNlcl0pXG5cbiAgLy8gU2FsdmFyIG5vIGxvY2FsU3RvcmFnZSBxdWFuZG8gbsOjbyBhdXRlbnRpY2Fkb1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNhcnRcIiwgSlNPTi5zdHJpbmdpZnkoaXRlbXMpKVxuICAgIH1cbiAgfSwgW2l0ZW1zLCBpc0F1dGhlbnRpY2F0ZWRdKVxuXG4gIGNvbnN0IGZldGNoQ2FydCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NhcnQnLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBjYXJ0RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEl0ZW1zID0gY2FydERhdGEubWFwKChpdGVtOiBhbnkpID0+ICh7XG4gICAgICAgICAgaWQ6IGl0ZW0ucHJvZHVjdC5faWQsXG4gICAgICAgICAgbmFtZTogaXRlbS5wcm9kdWN0Lm5hbWUsXG4gICAgICAgICAgZGVzY3JpY2FvOiBpdGVtLnByb2R1Y3QuZGVzY3JpcHRpb24sXG4gICAgICAgICAgcHJlY286IGl0ZW0ucHJvZHVjdC5wcmljZSxcbiAgICAgICAgICBjYXRlZ29yaWE6IGl0ZW0ucHJvZHVjdC5jYXRlZ29yeSxcbiAgICAgICAgICBpbWFnZW06IGl0ZW0ucHJvZHVjdC5pbWFnZSxcbiAgICAgICAgICBkaXNwb25pdmVsOiBpdGVtLnByb2R1Y3QuaW5TdG9jayxcbiAgICAgICAgICBxdWFudGlkYWRlOiBpdGVtLnF1YW50aXR5XG4gICAgICAgIH0pKVxuICAgICAgICBzZXRJdGVtcyh0cmFuc2Zvcm1lZEl0ZW1zKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGNhcnJpbmhvOicsIGVycm9yKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFkZEl0ZW0gPSBhc3luYyAocHJvZHV0bzogUHJvZHV0bywgcXVhbnRpdHk6IG51bWJlciA9IDEpID0+IHtcbiAgICBpZiAoaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKClcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jYXJ0Jywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1dG8uaWQsXG4gICAgICAgICAgICBxdWFudGl0eVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgYXdhaXQgZmV0Y2hDYXJ0KCkgLy8gUmVjYXJyZWdhciBjYXJyaW5ob1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgYW8gY2FycmluaG86JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEzDs2dpY2EgbG9jYWwgcGFyYSB1c3XDoXJpb3MgbsOjbyBhdXRlbnRpY2Fkb3NcbiAgICAgIHNldEl0ZW1zKChwcmV2SXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gcHJldkl0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IHByb2R1dG8uaWQpXG5cbiAgICAgICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgICAgIHJldHVybiBwcmV2SXRlbXMubWFwKChpdGVtKSA9PiBcbiAgICAgICAgICAgIGl0ZW0uaWQgPT09IHByb2R1dG8uaWQgXG4gICAgICAgICAgICAgID8geyAuLi5pdGVtLCBxdWFudGlkYWRlOiBpdGVtLnF1YW50aWRhZGUgKyBxdWFudGl0eSB9IFxuICAgICAgICAgICAgICA6IGl0ZW1cbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5wcmV2SXRlbXMsIHsgLi4ucHJvZHV0bywgcXVhbnRpZGFkZTogcXVhbnRpdHkgfV1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCByZW1vdmVJdGVtID0gYXN5bmMgKHByb2R1dG9JZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY2FydD9wcm9kdWN0SWQ9JHtwcm9kdXRvSWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBhd2FpdCBmZXRjaENhcnQoKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgZG8gY2FycmluaG86JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEl0ZW1zKChwcmV2SXRlbXMpID0+IHByZXZJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uaWQgIT09IHByb2R1dG9JZCkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlUXVhbnRpdHkgPSBhc3luYyAocHJvZHV0b0lkOiBzdHJpbmcsIHF1YW50aWRhZGU6IG51bWJlcikgPT4ge1xuICAgIGlmIChxdWFudGlkYWRlIDw9IDApIHtcbiAgICAgIGF3YWl0IHJlbW92ZUl0ZW0ocHJvZHV0b0lkKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2FydCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1dG9JZCxcbiAgICAgICAgICAgIHF1YW50aXR5OiBxdWFudGlkYWRlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBhd2FpdCBmZXRjaENhcnQoKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGF0dWFsaXphciBjYXJyaW5obzonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoKHByZXZJdGVtcykgPT4gXG4gICAgICAgIHByZXZJdGVtcy5tYXAoKGl0ZW0pID0+IFxuICAgICAgICAgIGl0ZW0uaWQgPT09IHByb2R1dG9JZCA/IHsgLi4uaXRlbSwgcXVhbnRpZGFkZSB9IDogaXRlbVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2xlYXJDYXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIC8vIFBhcmEgdXN1w6FyaW9zIGF1dGVudGljYWRvcywgbyBjYXJyaW5obyBzZXLDoSBsaW1wbyBubyBzZXJ2aWRvciBkdXJhbnRlIG8gY2hlY2tvdXRcbiAgICAgIHNldEl0ZW1zKFtdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJdGVtcyhbXSlcbiAgICB9XG4gIH1cblxuICBjb25zdCB0b3RhbCA9IGl0ZW1zLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnByZWNvICogaXRlbS5xdWFudGlkYWRlLCAwKVxuXG4gIHJldHVybiAoXG4gICAgPENhcnRDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgYWRkSXRlbSxcbiAgICAgICAgcmVtb3ZlSXRlbSxcbiAgICAgICAgdXBkYXRlUXVhbnRpdHksXG4gICAgICAgIGNsZWFyQ2FydCxcbiAgICAgICAgdG90YWwsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NhcnRDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYXJ0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChDYXJ0Q29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUNhcnQgZGV2ZSBzZXIgdXNhZG8gZGVudHJvIGRlIHVtIENhcnRQcm92aWRlclwiKVxuICB9XG4gIHJldHVybiBjb250ZXh0XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUF1dGgiLCJDYXJ0Q29udGV4dCIsInVuZGVmaW5lZCIsIkNhcnRQcm92aWRlciIsImNoaWxkcmVuIiwiaXRlbXMiLCJzZXRJdGVtcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwidXNlciIsImdldFRva2VuIiwiaXNBdXRoZW50aWNhdGVkIiwiZmV0Y2hDYXJ0Iiwic2F2ZWRDYXJ0IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ0b2tlbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJjYXJ0RGF0YSIsImpzb24iLCJ0cmFuc2Zvcm1lZEl0ZW1zIiwibWFwIiwiaXRlbSIsImlkIiwicHJvZHVjdCIsIl9pZCIsIm5hbWUiLCJkZXNjcmljYW8iLCJkZXNjcmlwdGlvbiIsInByZWNvIiwicHJpY2UiLCJjYXRlZ29yaWEiLCJjYXRlZ29yeSIsImltYWdlbSIsImltYWdlIiwiZGlzcG9uaXZlbCIsImluU3RvY2siLCJxdWFudGlkYWRlIiwicXVhbnRpdHkiLCJhZGRJdGVtIiwicHJvZHV0byIsIm1ldGhvZCIsImJvZHkiLCJwcm9kdWN0SWQiLCJlcnJvckRhdGEiLCJFcnJvciIsIm1lc3NhZ2UiLCJwcmV2SXRlbXMiLCJleGlzdGluZ0l0ZW0iLCJmaW5kIiwicmVtb3ZlSXRlbSIsInByb2R1dG9JZCIsImZpbHRlciIsInVwZGF0ZVF1YW50aXR5IiwiY2xlYXJDYXJ0IiwidG90YWwiLCJyZWR1Y2UiLCJzdW0iLCJQcm92aWRlciIsInZhbHVlIiwidXNlQ2FydCIsImNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/cart-provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./hooks/use-auth.ts":
/*!***************************!*\
  !*** ./hooks/use-auth.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useAuth auto */ \nfunction useAuth() {\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAuth.useEffect\": ()=>{\n            // Verificar se há token no localStorage\n            const token = localStorage.getItem('token');\n            const userData = localStorage.getItem('user');\n            if (token && userData) {\n                try {\n                    setUser(JSON.parse(userData));\n                } catch (error) {\n                    console.error('Erro ao carregar dados do usuário:', error);\n                    localStorage.removeItem('token');\n                    localStorage.removeItem('user');\n                }\n            }\n            setLoading(false);\n        }\n    }[\"useAuth.useEffect\"], []);\n    const login = (token, userData)=>{\n        localStorage.setItem('token', token);\n        localStorage.setItem('user', JSON.stringify(userData));\n        setUser(userData);\n    };\n    const logout = ()=>{\n        localStorage.removeItem('token');\n        localStorage.removeItem('user');\n        setUser(null);\n    };\n    const getToken = ()=>{\n        return localStorage.getItem('token');\n    };\n    return {\n        user,\n        loading,\n        login,\n        logout,\n        getToken,\n        isAuthenticated: !!user\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1hdXRoLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs2REFFMkM7QUFVcEMsU0FBU0U7SUFDZCxNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR0osK0NBQVFBLENBQWM7SUFDOUMsTUFBTSxDQUFDSyxTQUFTQyxXQUFXLEdBQUdOLCtDQUFRQSxDQUFDO0lBRXZDQyxnREFBU0E7NkJBQUM7WUFDUix3Q0FBd0M7WUFDeEMsTUFBTU0sUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1lBQ25DLE1BQU1DLFdBQVdGLGFBQWFDLE9BQU8sQ0FBQztZQUV0QyxJQUFJRixTQUFTRyxVQUFVO2dCQUNyQixJQUFJO29CQUNGTixRQUFRTyxLQUFLQyxLQUFLLENBQUNGO2dCQUNyQixFQUFFLE9BQU9HLE9BQU87b0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO29CQUNwREwsYUFBYU8sVUFBVSxDQUFDO29CQUN4QlAsYUFBYU8sVUFBVSxDQUFDO2dCQUMxQjtZQUNGO1lBRUFULFdBQVc7UUFDYjs0QkFBRyxFQUFFO0lBRUwsTUFBTVUsUUFBUSxDQUFDVCxPQUFlRztRQUM1QkYsYUFBYVMsT0FBTyxDQUFDLFNBQVNWO1FBQzlCQyxhQUFhUyxPQUFPLENBQUMsUUFBUU4sS0FBS08sU0FBUyxDQUFDUjtRQUM1Q04sUUFBUU07SUFDVjtJQUVBLE1BQU1TLFNBQVM7UUFDYlgsYUFBYU8sVUFBVSxDQUFDO1FBQ3hCUCxhQUFhTyxVQUFVLENBQUM7UUFDeEJYLFFBQVE7SUFDVjtJQUVBLE1BQU1nQixXQUFXO1FBQ2YsT0FBT1osYUFBYUMsT0FBTyxDQUFDO0lBQzlCO0lBRUEsT0FBTztRQUNMTjtRQUNBRTtRQUNBVztRQUNBRztRQUNBQztRQUNBQyxpQkFBaUIsQ0FBQyxDQUFDbEI7SUFDckI7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcGVsb3JvL0Rlc2t0b3AvQ29uZG9taW5pby9vbmxpbmVfc3RvcmVfcHJvamVjdC9maW5hbF9vbmxpbmVfc3RvcmVfcHJvamVjdC9ob29rcy91c2UtYXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuXG5pbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgYXBhcnRtZW50OiBzdHJpbmdcbiAgYWRtaW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dGgoKSB7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVmVyaWZpY2FyIHNlIGjDoSB0b2tlbiBubyBsb2NhbFN0b3JhZ2VcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpXG4gICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcicpXG4gICAgXG4gICAgaWYgKHRva2VuICYmIHVzZXJEYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRVc2VyKEpTT04ucGFyc2UodXNlckRhdGEpKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBkYWRvcyBkbyB1c3XDoXJpbzonLCBlcnJvcilcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJylcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICB9LCBbXSlcblxuICBjb25zdCBsb2dpbiA9ICh0b2tlbjogc3RyaW5nLCB1c2VyRGF0YTogVXNlcikgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbicsIHRva2VuKVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyJywgSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKVxuICAgIHNldFVzZXIodXNlckRhdGEpXG4gIH1cblxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJylcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpXG4gICAgc2V0VXNlcihudWxsKVxuICB9XG5cbiAgY29uc3QgZ2V0VG9rZW4gPSAoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVzZXIsXG4gICAgbG9hZGluZyxcbiAgICBsb2dpbixcbiAgICBsb2dvdXQsXG4gICAgZ2V0VG9rZW4sXG4gICAgaXNBdXRoZW50aWNhdGVkOiAhIXVzZXJcbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUF1dGgiLCJ1c2VyIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXNlckRhdGEiLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImNvbnNvbGUiLCJyZW1vdmVJdGVtIiwibG9naW4iLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwibG9nb3V0IiwiZ2V0VG9rZW4iLCJpc0F1dGhlbnRpY2F0ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-auth.ts\n"));

/***/ })

});